// let's imagine this file is autogenerated from the backend
// ideally, we want to keep these api related types in sync
// with the backend instead of manually writing them out

export type BaseEntity = {
  createdAt: number;
  id: string;
};

export type Entity<T> = {
  [K in keyof T]: T[K];
} & BaseEntity;

export type User = Entity<{
  bio: string;
  branch_id: number | null; // Assuming branch_id can be null based on the JSON
  company_id: number | null; // Assuming company_id can be null based on the JSON
  created_at: string; // Date string, adjust to Date type if needed
  email: string;
  email_verified_at: string | null; // Date string or null
  fcm_token: string | null; // Assuming fcm_token can be null based on the JSON
  firstName: string;
  id: number;
  jwt: string;
  lastName: string;
  name: string;
  role: 'ADMIN' | 'USER';
  role_id: number; // Assuming role_id is a number based on the JSON
  teamId: string;
  updated_at: string; // Date string, adjust to Date type if needed
  username: string;
}>;

export type AuthResponse = {
  token: string;
  user: User;
};

export type Team = Entity<{
  description: string;
  name: string;
}>;

export type Discussion = Entity<{
  author: User;
  body: string;
  teamId: string;
  title: string;
}>;

export type Booking = Entity<{
  dropoff_address: string;
  id: number;
  payment_type_id: number;
  pickup_address: string;
  reference_no: string;
  status: string;
  total_fare: number;
  trip_type: string;
}>;

export type Bookings = Entity<{
  canceled: Array<Booking>;
  delivered: Array<Booking>;
  inprogress: Array<Booking>;
}>;

export type VehicleType = Entity<{
  id: number;
  name: string;
}>;

export type Place = Entity<{
  id: number;
  landmark: string;
  latitude?: number;
  longitude?: number;
  name: string;
}>;

export type Store = Entity<{
  address: string;
  close_time: string; // e.g. "22:00:00"
  created_at: string; // ISO timestamp
  description: string | null;
  id: number;
  latitude: number | null;
  longitude: number | null;
  name: string;
  open_time: string; // e.g. "08:00:00"
  owner_id: number;
  status: 'open' | 'closed' | string; // string fallback in case there are other statuses
  updated_at: string; // ISO timestamp
}>;

export type Order = Entity<{
  distance: string;
  driver_id: number;
  dropoff_address: string;
  payment_type_id: string;
  pickup_address: string;
  total_driver_fare: string;
  total_price: string;
  total_transaction_fare: string;
  trip_type: string;
}>;

export type Cargo = Entity<{
  distance: string;
  driver_id: number;
  dropoff_address: string;
  payment_type_id: string;
  pickup_address: string;
  size: string;
  total_driver_fare: string;
  total_price: string;
  total_transaction_fare: string;
}>;

export type RideOption = {
  distance: string;
  driver: {
    id: number;
    name: string;
  };
  duration: number;
  fareDetails: {
    totalDriverFare: string;
    totalFare: string;
    totalTransactionFare: string;
  };
  id: number;
  vehicle_id: number;
  vehicle_type: string;
};

export type TimeSlot = Entity<{
  id: number;
  label: string;
  value: string;
}>;

export type WaitingTime = Entity<{
  id: number;
  name: string;
}>;

export type Customer = Entity<{
  branch_id: string | null;
  company_id: string;
  contact_no?: string;
  created_at: number; // Assuming you store createdAt as a timestamp or number in the backend
  email: string;
  email_verified_at?: Date | null;
  fcm_token?: string;
  name: string;
  password: string;
  remember_token?: string | null;
  role_id: string;
  updated_at: number; // Assuming you store updatedAt as a timestamp or number in the backend
  username: string;
}>;

export type CarRideBooking = Entity<{
  created_at?: Date;
  customer: Customer;
  customer_id?: number;
  distance?: number;
  driver: Driver;
  driver_id?: number;
  dropoff_address?: string;
  dropoff_latitude?: number;
  dropoff_longitude?: number;
  id: number;
  notes?: string;
  payment_type_id?: number;
  pickup_address?: string;
  pickup_distance?: number;
  pickup_latitude?: number;
  pickup_longitude?: number;
  reference_no?: string;
  ride_time: string;
  status: 'pending' | 'accepted' | 'completed' | 'cancelled' | 'arrived';
  total_driver_fare: number;
  total_fare: number;
  total_transaction_fare: number;
  trip_type: 'oneway' | 'roundtrip';
  updated_at?: Date;
}>;

export type Driver = Entity<{
  car_ride_booking?: Array<CarRideBooking>; // Assuming CarRideBooking is an array of CarRideBooking entities
  created_at: string | null; // Date string or null, adjust to Date type if needed
  created_by: number;
  id: number;
  is_active: number;
  latitude: string | null; // Assuming latitude can be null based on the JSON
  longitude: string | null; // Assuming longitude can be null based on the JSON
  status: 'notified' | 'active' | 'inactive'; // Adjust based on possible status values
  updated_at: string; // Date string, adjust to Date type if needed
  updated_by: number;
  user: User;
  user_id: number;
}>;
